import numpy as np
import math
import subprocess
import frzout
import freestream
try:
    from scipy.interpolate import CubicSpline
except ImportError:
    from scipy.interpolate import InterpolatedUnivariateSpline as CubicSpline
from scipy.interpolate import PchipInterpolator

import matplotlib.pyplot as plt
    

"""
Generating plots 4-6 from arXiv:160406346v3 (Vovchenko electromagnetic probes paper). 
Much of the code is adapted from hic-eventgen's run-events at https://github.com/Duke-QCD/hic-eventgen
"""

grid_step = 0.075
grid_n = math.ceil(2*15/grid_step)
grid_max = 0.5*grid_n*grid_step

def run_hydro(fs, event_size, coarse=False, dt_ratio=0.25):
    """
    Run the initial condition contained in FreeStreamer object `fs` through
    osu-hydro-pce on a grid with approximate physical size `event_size` [fm].
    Return a dict of freeze-out surface data suitable for passing directly
    to frzout.Surface.

    Initial condition arrays are cropped or padded as necessary.

    If `coarse` is an integer > 1, use only every `coarse`th cell from the
    initial condition arrays (thus increasing the physical grid step size
    by a factor of `coarse`).  Ignore the user input `hydro_args` and
    instead run ideal hydro down to a low temperature.

    `dt_ratio` sets the timestep as a fraction of the spatial step
    (dt = dt_ratio * dxy).  The SHASTA algorithm requires dt_ratio < 1/2.
    """
    
    dxy = grid_step * (coarse or 1)
    ls = math.ceil(event_size/dxy)
    n = 2*ls + 1
    
    for fmt, f, arglist in [
            ('ed', fs.energy_density, [()]),
            ('u{}', fs.flow_velocity, [(1,), (2,)]),
            ('pi{}{}', fs.shear_tensor, [(1,1),(1,2),(2,2)]),
            ]:
        for a in arglist:
            X= f(*a)
            
            if coarse:
                X = X[::coarse, ::coarse]
                
            diff = X.shape[0] -n
            start = int(abs(diff)/2)
            
            if diff > 0:
                s = slice(start, start + n)
                X = X[s,s]
            elif diff < 0:
                Xn = np.zeros((n,n))
                s = slice(start, start + X.shape[0])
                Xn[s,s] = X
                X = Xn
            
            X.tofile(fmt.format(*a) + '.dat')
    dt = 0.01        
    #dt = dxy * dt_ratio

    subprocess.run(['osu-hydro-pce', 't0=0.1', 'teq=5.0', 'dt={}'.format(dt), 'dxy={}'.format(dxy), 'nls={}'.format(ls), 'tfinal=2.0'],
                    check=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
  #  print(subprocess.getoutput(['osu-hydro-pce', 't0=0.1', 'teq=5.0', 'dt={}'.format(dt), 'dxy={}'.format(dxy), 'nls={}'.format(ls)]))
    
    surface = np.fromfile('surface.dat', dtype='f8').reshape(-1, 18)
    
    return dict(
    zip(['x', 'sigma', 'v'], np.hsplit(surface, [3,6,8])),
    pi=dict(zip(['xx','xy','yy'],surface.T[11:14])),
    Pi=surface.T[15],
    Temp = surface.T[16],
    ed = surface.T[17])

def run_single_event(ic):
    """
    Run the initial condition event contained in HDF5 dataset object `ic`
    and save observables to `results`.

    """    
    fs = freestream.FreeStreamer(ic, grid_max, 0.5)
    # rmax = math.sqrt((run_hydro(fs, event_size=27, coarse=3)['x'][:,1:3]**2).sum(axis=1).max())
    # print(rmax)
    results = run_hydro(fs, event_size=10)
    return results

""" Read in profile generated by average_events.py """
profile = np.load('profile13.npy')

tspace = np.linspace(0.1, 12, 1191)
results = run_single_event(profile)
#surface = frzout.Surface(**results, ymax=2)   
tvals = results['x'][:,0]
xvals = results['x'][:,1]
yvals = results['x'][:,2]
rvals = np.sqrt(xvals**2 + yvals**2)

""" Calculating fugacity at each time """
#indices = []

# for t in tspace:
#     newindex = int(np.argmax(results['x'][:,0] > t))
#     if (newindex == 0 and t > tspace[0]):
#         break
#     indices.append(newindex)
    
# def fugacity(t):
#     return 1 - np.exp((0.1 - t)/5.0)

# fugvals = np.ones(results['x'][:,0].size)
# for i in range(1,len(indices)):
#     if i == (len(indices)-1):
#         fugvals[indices[i-1]:] = fugacity(tspace[i-1])
#     else:
#         fugvals[indices[i-1]:indices[i]] = fugacity(tspace[i-1])

""" tempvals gives temperature in MeV, evals gives energy density in GeV/fm^3 """
tempvals = 1000*results['Temp']
evals = results['ed']

plt.rcdefaults()
plt.style.use(['seaborn-darkgrid', 'seaborn-deep', 'seaborn-notebook'])
plt.rcParams.update({
    'lines.linewidth': 1.5,
    'font.family': 'sans-serif',
    'font.sans-serif': ['Lato'],
    'mathtext.fontset': 'custom',
    'mathtext.default': 'it',
    'mathtext.rm': 'sans',
    'mathtext.it': 'sans:italic:medium',
    'mathtext.cal': 'sans',
    'pdf.fonttype': 42,
})
plt.figure(figsize=(7,5))

""" 2D scatter plot of either energy density (evals) or temperature (tempvals) over space and time: """
# levels = np.arange(0, 400, 1) 
# cmap = plt.cm.jet
# plt.xlabel('x (fm)')
# plt.ylabel(r'$\tau$ (fm/c)')
# plt.scatter(rvals, tvals, c=evals, cmap=plt.cm.jet)
# plt.colorbar(label=r'$\epsilon (GeV/fm^3)$')

""" 1D plot of initial energy density over x: """
### Saved to plots/InitialEnergyDensity.png
#plt.xlabel('x (fm)')
#plt.ylabel(r'$\epsilon (GeV/fm^3)$')
#plt.scatter(rvals, evals, s = 1.0)
    
""" Plot of energy density in central cell: """
### Saved to plots/CentralCell.png
plt.xlabel(r'$\tau$ (fm/c)')
plt.ylabel(r'$\epsilon (GeV/fm^3)$')
rvals_original = rvals
rvals = rvals[rvals<2*grid_step]
tvals = tvals[rvals_original<2*grid_step]
evals = evals[rvals_original<2*grid_step]
plt.plot(tvals, evals)
